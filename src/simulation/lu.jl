# ------------------------------------------------------------------
# Licensed under the MIT License. See LICENCE in the project root.
# ------------------------------------------------------------------

"""
    LUGS(var‚ÇÅ=>param‚ÇÅ, var‚ÇÇ=>param‚ÇÇ, ...)

The LU Gaussian simulation solver introduced by Alabert 1987.
The full covariance matrix is built to include all locations
of the simulation domain, and samples from the multivariate
Gaussian are drawn via LU factorization.

## Parameters

* `variogram`     - Theoretical variogram (default to `GaussianVariogram()`)
* `mean`          - Mean of unconditional simulation (default to `0`)
* `factorization` - Factorization method (default to `cholesky`)

## Joint parameters

* `correlation` - correlation coefficient between two covariates (default to `0`).

## Global parameters

* `init` - Data initialization method (default to `NearestInit()`)
* `rng`  - Random number generator (default to `Random.GLOBAL_RNG`)

## Examples

Simulate two variables `var‚ÇÅ` and `var‚ÇÇ` independently:

```julia
julia> LUGS(
         :var‚ÇÅ => (; variogram=SphericalVariogram(), mean=10.0),
         :var‚ÇÇ => (; variogram=GaussianVariogram())
       )
```

Simulate two correlated variables `var‚ÇÅ` and `var‚ÇÇ` with correlation `0.7`:

```julia
julia> LUGS(
         :var‚ÇÅ => (; variogram=SphericalVariogram(), mean=10.0),
         :var‚ÇÇ => (; variogram=GaussianVariogram()),
         (:var‚ÇÅ, :var‚ÇÇ) => (; correlation=0.7)
       )
```

### References

* Alabert 1987. [The practice of fast conditional simulations
  through the LU decomposition of the covariance matrix]
  (https://link.springer.com/article/10.1007/BF00897191)

* Oliver 2003. [Gaussian cosimulation: modeling of the cross-covariance]
  (https://link.springer.com/article/10.1023%2FB%3AMATG.0000002984.56637.ef)

### Notes

* The solver is only adequate for domains with relatively small
  number of elements (e.g. 100x100 grids) where it is feasible to
  factorize the full covariance.

* For larger domains (e.g. 3D grids), other solvers are preferred
  such as [`SGS`](@ref) and [`FFTGS`](@ref).
"""
@simsolver LUGS begin
  @param variogram = GaussianVariogram()
  @param mean = nothing
  @param factorization = cholesky
  @jparam correlation = 0.0
  @global init = NearestInit()
  @global rng = Random.GLOBAL_RNG
end

function preprocess(problem::SimulationProblem, solver::LUGS)
  # retrieve problem info
  pdata = data(problem)
  pdomain = domain(problem)
  pvars = variables(problem)

  # retrieve global parameters
  init = solver.init

  # initialize buffers for realizations and simulation mask
  buff, mask = initbuff(pdomain, pvars, init, data=pdata)

  # result of preprocessing
  preproc = Dict()

  for covars in covariables(problem, solver)
    conames = covars.names
    coparams = Dict()

    # 1 or 2 variables can be simulated simultaneously
    @assert length(conames) ‚àà (1, 2) "invalid number of covariables"

    # preprocess parameters for individual variables
    for var in conames
      # get parameters for variable
      varparams = covars.params[Set([var])]

      # determine variogram model
      Œ≥ = varparams.variogram

      # determine factorization method
      fact = varparams.factorization

      # check stationarity
      @assert isstationary(Œ≥) "variogram model must be stationary"

      # retrieve data locations and data values in domain
      dlocs = findall(mask[var])
      z‚ÇÅ = view(buff[var], dlocs)

      # retrieve simulation locations
      slocs = [l for l in 1:nelements(pdomain) if l ‚àâ dlocs]

      # create views of the domain
      ùíüd = [centroid(pdomain, i) for i in dlocs]
      ùíüs = [centroid(pdomain, i) for i in slocs]

      # covariance between simulation locations
      C‚ÇÇ‚ÇÇ = sill(Œ≥) .- Variography.pairwise(Œ≥, ùíüs)

      if isempty(dlocs)
        d‚ÇÇ = zero(eltype(z‚ÇÅ))
        L‚ÇÇ‚ÇÇ = fact(Symmetric(C‚ÇÇ‚ÇÇ)).L
      else
        # covariance beween data locations
        C‚ÇÅ‚ÇÅ = sill(Œ≥) .- Variography.pairwise(Œ≥, ùíüd)
        C‚ÇÅ‚ÇÇ = sill(Œ≥) .- Variography.pairwise(Œ≥, ùíüd, ùíüs)

        L‚ÇÅ‚ÇÅ = fact(Symmetric(C‚ÇÅ‚ÇÅ)).L
        B‚ÇÅ‚ÇÇ = L‚ÇÅ‚ÇÅ \ C‚ÇÅ‚ÇÇ
        A‚ÇÇ‚ÇÅ = B‚ÇÅ‚ÇÇ'

        d‚ÇÇ = A‚ÇÇ‚ÇÅ * (L‚ÇÅ‚ÇÅ \ z‚ÇÅ)
        L‚ÇÇ‚ÇÇ = fact(Symmetric(C‚ÇÇ‚ÇÇ - A‚ÇÇ‚ÇÅ * B‚ÇÅ‚ÇÇ)).L
      end

      if !isnothing(varparams.mean) && !isempty(dlocs)
        @warn "mean can only be specified in unconditional simulation"
      end

      # mean for unconditional simulation
      Œº = isnothing(varparams.mean) ? zero(eltype(z‚ÇÅ)) : varparams.mean

      # save preprocessed parameters for variable
      coparams[Set([var])] = (z‚ÇÅ, d‚ÇÇ, L‚ÇÇ‚ÇÇ, Œº, dlocs, slocs)
    end

    # preprocess joint parameters
    if length(conames) == 2
      # get parameters for pair of variables
      jparams = covars.params[conames]

      # 0-lag correlation between variables
      œÅ = jparams.correlation

      # save preprocessed parameters for pair of variables
      coparams[conames] = œÅ
    end

    push!(preproc, conames => coparams)
  end

  preproc
end

function solvesingle(::SimulationProblem, covars::NamedTuple, solver::LUGS, preproc)
  # random number generator
  rng = solver.rng

  # preprocessed parameters
  conames = covars.names
  coparams = preproc[conames]

  # plain list of variable names
  vars = collect(conames)

  # simulate first variable
  v‚ÇÅ = first(vars)
  Y‚ÇÅ, w‚ÇÅ = lusim(rng, coparams[Set([v‚ÇÅ])])
  result = Dict(v‚ÇÅ => Y‚ÇÅ)

  # simulate second variable
  if length(conames) == 2
    œÅ = coparams[conames]
    v‚ÇÇ = last(vars)
    Y‚ÇÇ, w‚ÇÇ = lusim(rng, coparams[Set([v‚ÇÇ])], œÅ, w‚ÇÅ)
    push!(result, v‚ÇÇ => Y‚ÇÇ)
  end

  result
end

function lusim(rng, params, œÅ=nothing, w‚ÇÅ=nothing)
  # unpack parameters
  z‚ÇÅ, d‚ÇÇ, L‚ÇÇ‚ÇÇ, Œº, dlocs, slocs = params

  # number of points in domain
  npts = length(dlocs) + length(slocs)

  # allocate memory for result
  y = Vector{eltype(z‚ÇÅ)}(undef, npts)

  # conditional simulation
  w‚ÇÇ = randn(rng, size(L‚ÇÇ‚ÇÇ, 2))
  if isnothing(œÅ)
    y‚ÇÇ = d‚ÇÇ .+ L‚ÇÇ‚ÇÇ * w‚ÇÇ
  else
    y‚ÇÇ = d‚ÇÇ .+ L‚ÇÇ‚ÇÇ * (œÅ * w‚ÇÅ + ‚àö(1 - œÅ^2) * w‚ÇÇ)
  end

  # hard data and simulated values
  y[dlocs] = z‚ÇÅ
  y[slocs] = y‚ÇÇ

  # adjust mean in case of unconditional simulation
  isempty(dlocs) && (y .+= Œº)

  y, w‚ÇÇ
end
